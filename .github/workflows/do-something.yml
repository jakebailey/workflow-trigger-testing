name: Do something

on:
  workflow_dispatch:
    inputs:
      args:
        description: 'An argument'
        required: true
        default: ''

      # For bot trigger
      distinct_id:
        description: '(bot) A distinct ID'
        required: false
        default: ''
      issue_number:
        description: '(bot) An issue number'
        required: false
        default: ''
      status_comment_id:
        description: '(bot) A comment ID'
        required: false
        default: ''

run-name: ${{ github.workflow }}${{ inputs.distinct_id && format(' (bot run {0})', inputs.distinct_id) || '' }}

permissions:
  contents: read
  issues: write
  pull-requests: write

# Ensure scripts are run with pipefail. See:
# https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#exit-codes-and-error-action-preference
defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - run: |
          sleep 20

      - run: |
          echo "Running with args: ${{ inputs.args }}"

      - uses: actions/github-script@v7
        env:
          DISTINCT_ID: ${{ inputs.distinct_id }}
          ISSUE_NUMBER: ${{ inputs.issue_number }}
          STATUS_COMMENT_ID: ${{ inputs.status_comment_id }}
          ARGS: ${{ inputs.args }}
        with:
          script: |
            const { DISTINCT_ID, ISSUE_NUMBER, STATUS_COMMENT_ID, ARGS } = process.env;

            let commentBody;
            switch (ARGS) {
              case "successfully":
                commentBody = `The results for \`${ARGS}\` are in!\n\nEverything looks good!`;
                break;
              case "interesting":
                commentBody = `The results for \`${ARGS}\` are in!\n\nSomething interesting changed!\n\n...`;
                break;
              case "failing":
                commentBody = `The results for \`${ARGS}\` are in!\n\nSomething went wrong!`;
                break;
              default:
                commentBody = `The results for \`${ARGS}\` are in!\n\nI don't know what to say!`;
                break;
            }


            // Post results
            const resultsComment = await github.rest.issues.createComment({
              issue_number: +ISSUE_NUMBER,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody,
            });

            let emoji;
            switch (ARGS) {
              case "successfully":
                emoji = "‚úÖ";
                break;
              case "interesting":
                emoji = "üëÄ";
                break;
              case "failing":
                emoji = "‚ùå";
                break;
              default:
                emoji = "‚ùì";
                break;
            }

            const toReplace = `<!--result-${DISTINCT_ID}-->`;
            while (true) {
              // Get status comment contents
              const statusComment = await github.rest.issues.getComment({
                comment_id: +STATUS_COMMENT_ID,
                owner: context.repo.owner,
                repo: context.repo.repo,
              });

              const oldComment = statusComment.data.body;
              if (!oldComment.includes(toReplace)) {
                break;
              }

              const newComment = oldComment.replace(
                toReplace,
                `[${emoji} Results](${resultsComment.data.html_url})`,
              )

              // Update status comment
              await github.rest.issues.updateComment({
                comment_id: +STATUS_COMMENT_ID,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: newComment,
              });

              // Repeat; someone may have edited the comment at the same time.
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
        if: ${{ inputs.distinct_id }}
